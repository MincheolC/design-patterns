# Mediator

중재자 패턴을 통해 **M:N의 관계를 1:1로 줄일 수** 있다.

### 의도

객체들의 상호작용을 캡슐화하는 객체를 정의. 즉, 객체들이 직접 서로를 참조하지 않도록 하여 객체 사이의 소결합(loose coupling)이 되도록 함.

### 문제

객체지향 개발 방법론에서는 행동을 여러 객체에 분산시켜 처리하도록 되어있고, 이는 객체들 간에 수 많은 연결관계가 존재하게 됨. 객체 상호 간의 의존성이 급증하여 재사용성이 저하 될 수 있음.(변경이 어려움)

### 활용성

- 여러 객체가 복잡한 상호작용을 가질 때.
    - 객체 간의 의존성이 구조화 되지 않고, 이해하기 어려울 때
- 한 개의 객체가 다른 객체를 너무 많이 참조하고, 의사소통하여 그 객체를 재 사용하기 힘들 때
- 여러 클래스에 분산된 행동들이 상속 없이 상황에 맞게 수정되어야 할 때

### 협력 방법

- Colleague는 Mediator에서 요청을 송수신함. Mediator는 필요한 Colleague에게 요청을 전달함.

### 구조

![mediator](images/mediator.png)

### 결과

- 서브 클래싱을 제한함.
    - 다른 객체 사이에 분산된 행동들을 1개의 객체(Mediator)로 국한함. 행동을 변경하려면 Mediator 클래스를 상속하는 서브 클래스만 만들면 됨. → Colleague 클래스들을 재사용 가능함.
- Colleague 객체들 사이의 종속성을 줄임. → Mediator, Colleague 클래스 각각을 독립적으로 다양화 및 재사용할 수 있음.
- 객체 간 관계를 단순화 함. → 이해, 유지, 확장이 쉬움.
- 객체 간 협력 방법을 추상화 함. → 사용자는 각 객체의 행동과 상관없이 객체 간 연결 방법에만 집중할 수 있음.
- 통제가 집중화 됨. → 상호작용의 복잡한 모든 것을 Mediator 내부에서만 오가게 함.

### 단점

- 객체 사이의 상호작용을 모두 Mediator에서 처리하기 때문에 복잡해질 수 있음. → Mediator클래스의 유지 보수가 어려워 짐.

### 관련 패턴

감시자 패턴과 경쟁적임. 감시자 패턴은 Observer, Subject를 통하여 객체 간의 상호교류를 분산시킨 패턴, 중재자 패턴은 다른 객체 사이의 교류를 Mediator 객체 내에 캡슐화한 패턴. 재사용이 가능한 객체 만들기 쉬운 건 감시자 패턴. 객체 간의 흐름을 파악하는데는 중재자 패턴이 낫다.

### 사용 예

[Mediator Design Pattern - Mediator Pattern in Java - HowToDoInJava](https://howtodoinjava.com/design-patterns/behavioral/mediator-pattern/)
