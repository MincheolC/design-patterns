## 명령 (Command or Action or Transaction)

### 목적
요청 자체를 캡슐화 한다. 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고, 요청을 대기시키거나 로깅하며, 되돌릴 수 있는 연산을 지원한다

### 동기
- 사용자 인터페이스 툴킷은 버튼과 메뉴 등을 포함하는데, 이는 사용자의 메시지를 처리한다. 그러나 툴킷은 이 메시지를 직접 처리할 수 없고(어떤 객체가 이 요청을 처리할지를 알아낼 방법이 없기 때문) 툴킷을 사용하는 응용프로그램만이 요청을 처리할 수 있다.(응용프로그램만이 어떤 객체를 통해서 어떤 일이 되어야 하는지 알기 때문) 이와 같이 요청받은 연산이 무엇이며, 이를 처리할 객체가 누구인지에 대한 정보 없이 임의의 객체에 메시지를 보내야 할 때 명령 패턴은 툴킷 객체가 요청 자체를 객체로 바꿈으로써 명시되지 않은 응요프로그램 객체의 요청을 처리할 수 있도록 지원하는 패턴이다.

### 활용
- 수행할 동작을 객체로 매개변수화하고자 할 때
- 서로 다른 시간에 요청을 명시하고, 저장하며, 실행하고 싶을 때: command 객체는 원래의 요청과 다른 생명주기가 있다
- 실행 취소 기능을 지원하고 싶을 때
- 시스템이 고장 났을 때 재적용이 가능하도록 변경 과정에 대한 로깅을 지원하고 싶을 때

### 구조
- Command: 연산 수행에 필요한 인터페이스를 선언
- ConcreteCommand: Receiver 객체와 액션 간의 연결성을 정의. 또한 처리 객체에 정의된 연산을 호출하도록 Excute를 구현
- Client: ConncreteCommand 객체를 생성하고 처리 객체로 정의
- Invoker: 명령어에 처리를 수행할 것을 요청
- Receiver: 요청에 관련된 연산 수행 방법을 알고 있다. 어떤 클래스도 요청 수신자로서 동작할 수 있다

### 이점
- Command는 연산을 호출하는 객체와 연산 수행 방법을 구현하는 객체를 분리
- Command는 일급 클래스(first-class)이다: 다른 객체와 같은 방식으로 조작되고 확장 할 수 있다
- 명령 여러 개를 복합해서 만들 수 있다
- 새로운 Command를 추가하기 쉽다: 기존 클래스를 변경할 필요 없이 단지 새로운 명령어에 대응하는 클래스만 정의하면 된다

### 참고
- https://moonshoo.tistory.com/5
- https://gdtbgl93.tistory.com/23
- https://medium.com/@lazysoul/functional-programming-%EC%97%90%EC%84%9C-1%EA%B8%89-%EA%B0%9D%EC%B2%B4%EB%9E%80-ba1aeb048059
